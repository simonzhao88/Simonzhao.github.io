{"pages":[{"title":"About-Me","text":"成都中医药大学 中医院校里专门搞计算机的 一枚Python程序员 生活多艰辛，只求努力不被辜负","path":"about-me/index.html"},{"title":"分类","text":"","path":"categories/index.html"},{"title":"标签","text":"","path":"tags/index.html"}],"posts":[{"title":"爬虫初探","text":"爬虫初探简介网络爬虫（Web Spider。又被称为网页蜘蛛。网络机器人，又称为网页追逐者），是一种依照一定的规则，自己主动的抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁，自己主动索引。模拟程序或者蠕虫。假设把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。 网络蜘蛛是通过网页的链接地址来寻找网页的。从站点某一个页面（一般是首页）開始，读取网页的内容。找到在网页中的其他链接地址。然后通过这些链接地址寻找下一个网页。这样一直循环下去，直到把这个站点全部的网页都抓取完为止。假设把整个互联网当成一个站点。那么网络蜘蛛就能够用这个原理把互联网上全部的网页都抓取下来。这样看来，网络爬虫就是一个爬行程序，一个抓取网页的程序。 简单地说，网络爬虫的基本任务就是抓取网页内容。 1.爬虫程序设计1.1 获取网页信息： ulrllib、urllib3、requests123requests为第三方的库，需要安装才能使用pip install requests 1.2解析网页信息：beautifulsoup4(bs4)、re、xpath、lxml 12345bs4为第三方的库，需要安装才能使用pip install beautifulsoup4使用的时候 from bs4 import BeautifulSoup 这样导入 Python 标准库中自带了 xml 模块，但是性能不够好，而且缺乏一些人性化的 API，相比之下，第三方库 lxml 是用 Cython 实现的，而且增加了很多实用的功能。1234567安装lxml，在新版本中无法使用from lxml import etree pip install lxml 并不推荐这样去安装lxml 推荐安装的方法：访问网站(https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml)下载lxml的安装whl文件，然后进行安装。 pip install lxml-4.2.1-cp36-cp36m-win_amd64.whl 2.网页分析2.1 请求头分析 使用chrome或者firefox浏览器，打开需要爬取的网页，F12进入开发者模式，查看网页请求头。123456789101112131415161718192021222324# 浏览器告诉服务器可以接收的文本类型, */*表示任何类型都可以接收Accept: text/html, */*;q=0.8# 浏览器告诉服务器，数据可以压缩，页面可以解压数据然后进行渲染。做爬虫的时候，最好不要写该参数Accept-Encoding: gzip, deflate # 语言类型Accept-Language: zh-CN,zh;q=0.9 Cache-Control: max-age=0# 保持连接Connection: keep-alive # 会话 Cookie: Hm_lvt_3bfcc098e0da26d58c321ba579b04b2f=1527581188,1528137133# 域名Host: www.cdtopspeed.com Upgrade-Insecure-Requests: 1# 用户代理, 使得服务器能够识别请求是通过浏览器请求过来的，其中包含浏览器的名称/版本等信息User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36 其中在爬虫中最重要的就是User-Agent：在下面urllib的使用中就会详细的解释User-Agent的使用 2.2 网页结构分析 通过查看网页html代码，分析要爬取数据在html当中的位置此过程需要细心，只有正确的分析出需要爬去数据的html结构，后续才能顺利拿到想要的数据 3.编写爬虫，urllib的使用使用urllib来获取百度首页的源码1234import urllib.requestr = urllib.request.urlopen('https://www.baidu.com')print(r.read().decode('utf-8')) 按照我们的想法来说，输出的结果应该是百度首页的源码才对，但是输出却不对(多请求几次，就会出现如下的结果)，如下结果： 12345678910&lt;html&gt;&lt;head&gt; &lt;script&gt; location.replace(location.href.replace(\"https://\",\"http://\")); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;noscript&gt;&lt;meta http-equiv=\"refresh\" content=\"0;url=http://www.baidu.com/\"&gt;&lt;/noscript&gt;&lt;/body&gt;&lt;/html&gt; 以上的结果并不是我们想要的，我们可以来查看一下为什么会出现这种问题的原因。我们可以想到刚才说的，请求头中的最重要的参数User-Agent参数，该参数是用来告诉服务器，请求的url是来源于哪儿的，是来源于浏览器还是来源于其他地方的。如果是来源于非浏览器的会就不会返回源码信息给你的，直接拦截掉你的请求 分析以上代码中，默认提交的请求头中的User-Agent到底传递了什么值：通过查看request源代码，发现传入的User-Agent的值是：Python-urllib/3.6(当前环境的Python版本信息) 接下来，就是优化以上的代码，实现目的就是告诉服务器我们这个请求是来源于浏览器的。 12345678header = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/65.0.3325.181 Safari/537.36'&#125;res = urllib.request.Request('https://www.baidu.com', headers=header)# 读取url的页面源码r = urllib.request.urlopen(res)# decode解码，encode编码print(r.read().decode('utf-8')) 按照这样去解析，就可以获取到百度的首页源代码了，展示部分代码如下：123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\"&gt;&lt;meta content=\"always\" name=\"referrer\"&gt;&lt;meta name=\"theme-color\" content=\"#2932e1\"&gt;&lt;link rel=\"shortcut icon\" href=\"/favicon.ico\" type=\"image/x-icon\" /&gt;&lt;link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/content-search.xml\" title=\"百度搜索\" /&gt;&lt;link rel=\"icon\" sizes=\"any\" mask href=\"//www.baidu.com/img/baidu_85beaf5496f291521eb75ba38eacbd87.svg\"&gt;&lt;link rel=\"dns-prefetch\" href=\"//s1.bdstatic.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t1.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t2.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t3.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t10.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t11.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//t12.baidu.com\"/&gt;&lt;link rel=\"dns-prefetch\" href=\"//b1.bdstatic.com\"/&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;...... 通过简单的一段代码，我们就完成了对百度的网页爬取！ 4.SSL(补充)什么是 SSL 证书？ SSL 证书就是遵守 SSL 安全套接层协议的服务器数字证书。 而 SSL 安全协议最初是由美国网景 Netscape Communication 公司设计开发的，全称为：安全套接层协议 (Secure Sockets Layer) ， 它指定了在应用程序协议 ( 如 HTTP 、 Telnet 、 FTP) 和 TCP/IP 之间提供数据安全性分层的机制，它是在传输通信协议 (TCP/IP) 上实现的一种安全协议，采用公开密钥技术，它为 TCP/IP 连接提供数据加密、服务器认证、消息完整性以及可选的客户机认证。由于此协议很好地解决了互联网明文传输的不安全问题，很快得到了业界的支持，并已经成为国际标准。 SSL 证书由浏览器中“受信任的根证书颁发机构”在验证服务器身份后颁发，具有网站身份验证和加密传输双重功能。 如果能使用 https:// 来访问某个网站，就表示此网站是部署了SSL证书。一般来讲，如果此网站部署了SSL证书，则在需要加密的页面会自动从 http:// 变为 https:// ，如果没有变，你认为此页面应该加密，您也可以尝试直接手动在浏览器地址栏的http后面加上一个英文字母“ s ”后回车，如果能正常访问并出现安全锁，则表明此网站实际上是部署了SSL证书，只是此页面没有做 https:// 链接；如果不能访问，则表明此网站没有部署 SSL证书。 案例: 访问加密的12306的网站 如果不忽略ssl的安全认证的话，网页的源码会提示ssl认证问题，需要提供ssl认证。我们在做爬虫的时候，自动设置忽略掉ssl认证即可。代码如下： 123456789101112import sslimport urllib.requestdef main(): url = 'https://www.12306.cn/mormhweb/' # 忽略未经审核的ssl认证 context = ssl._create_unverified_context() res = urllib.request.urlopen(url, context=context) print(res.read().decode('utf-8'))if __name__ == '__main__': main()","path":"2018/06/15/爬虫初探/"},{"title":"将django项目部署到CentOS服务器上","text":"将django项目部署到CentOS服务器上安装mariadb安装命令1yum -y install mariadb mariadb-server 安装完成MariaDB，首先启动MariaDB 1systemctl start mariadb 设置开机启动1systemctl enable mariadb 设置密码命令:123mysql_secure_installationEnter current password for root:&lt;–初次运行直接回车 设置密码12345Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车New password: &lt;– 设置root用户的密码Re-enter new password: &lt;– 再输入一次你设置的密码 其他配置1234567Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，回车Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,回车,Remove test database and access to it? [Y/n] &lt;– 是否删除test数据库，回车Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车 初始化MariaDB完成，接下来测试登录1mysql -u root -p 开启远程连接在mysql数据库中的user表中可以看到默认是只能本地连接的，所有可以添加一个新的用户，该用户可以远程访问 1. 创建用户1234567891011121314151617181920212223242526# 先使用数据库use mysql;# 针对ipcreate user &apos;root&apos;@&apos;192.168.10.10&apos; identified by &apos;password&apos;;#全部 create user &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;;2. 授权# 给用户最大权限grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos;;# 给部分权限(test 数据库)grant all privileges on test.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos; with grant option;# 刷新权限表flush privileges;# 查看show grants for &apos;root&apos;@&apos;localhost&apos;;接下来就可以在远程的数据库可视化工具中直接访问该服务器中的mysql了。# 访问数据库mysql -u root -p 安装python3.6在centos中，系统默认只提供python2.7的版本，但是项目我们使用的python3.6的版本。所有我们自己安装python3 安装Python3的方法首先安装依赖包1234yum -y groupinstall &quot;Development tools&quot;yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 然后根据自己需求下载不同版本的Python3，我下载的是Python3.6.2 1wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz 然后解压压缩包，进入该目录，安装Python31234tar -xvJf Python-3.6.2.tar.xzcd Python-3.6.2./configure --prefix=/usr/local/python3make &amp;&amp; make install 最后创建软链接1234ln -s /usr/local/python3/bin/python3 /usr/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 安装环境1. 安装virtualenv1yum install python-virtualenv 2. 创建虚拟环境123456virtualenv --no-site-packages envcd env# 激活虚拟环境source bin/activate 3. 安装环境需要的包123pip3 install -r re_install.txt其中re_install.txt文件中记录的是需要安装包的名称以及对应的版本 部署该部署采用的是cenots7系统来部署 Django的项目中，在工程目录下settings.py文件中有一个DEBUG=True参数，如果DEBUG=False则会出现js,css，img无法加载的情况出现。 原因如下： Django框架仅在开发模式下提供静态文件服务。当我开启DEBUG模式时，Django内置的服务器是提供静态文件的服务的，所以css等文件访问都没有问题，但是关闭DEBUG模式后，Django便不提供静态文件服务了。想一想这是符合Django的哲学的：这部分事情标准服务器都很擅长，就让服务器去做吧！ 1. 测试环境中部署方式在测试环境中一般都直接使用python manage.py runserver的方式去运行项目。其中就涉及到DEBUG=False的修改，静态目录的修改等，具体修改如下：12345678910111213141516修改settings.py配置文件中的DEBUG=False模式，修改ALLOEWD_HOST=[&apos;*&apos;]修改工程目录下的urls.pyfrom django.views.static import serveurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^axf/&apos;, include(&apos;axf.urls&apos;, namespace=&apos;axf&apos;)), # 增加以下的url路由 url(r&apos;^static/(?P&lt;path&gt;.*)$&apos;, serve, &#123;&quot;document_root&quot;: settings.STATICFILES_DIRS[0]&#125;), url(r&apos;^$&apos;, views.home)] 2. 正式环境中部署方式正式环境中部署为nginx+uwsgi来部署django项目 2.1 安装nginxa）添加nginx存储库1yum install epel-release b) 安装nginx1yum install nginx c) 运行nginx Nginx不会自行启动。要运行Nginx start nginx```12nginx的运行命令： systemctl status nginx 查看nginx的状态 systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动123d）系统启动时启用Nginx```systemctl enable nginx e）如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信：12345sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload 运行结果如下: 3.配置uwsgi 3.1 安装uwsgipip3 install uwsgi然后进行环境变量的配置， 建立软连接1ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi 4. 配置项目代码，配置项目nginx，配置uwsgi.ini等本案例的配置文件，都习惯将每一个项目的配置文件，日志文件，虚拟环境放在一起，这样开发方便，运维也方便维护 项目的目录结构如下： 其中： conf是配置文件，用于存放项目的nginx.conf文件，uwsgi.ini文件 logs是日志文件，用于存放nginx的启动成功和失败文件，以及uwsgi的运行日志文件 env是用于存放虚拟环境 src是项目文件，该目录下上传的是目录代码 4.1 配置nginx.conf文件首先：编写自己项目的nginx.conf文件如下： 每一个项目对应有一个自己定义的nginx的配置文件，比如爱鲜蜂项目，我定义为axfnginx.conf文件1234567891011121314151617server &#123; listen 80; server_name 39.104.176.9 localhost; access_log /home/logs/access.log; error_log /home/logs/error.log; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8890; &#125; location /static/ &#123; alias /home/src/axf/static/; expires 30d; &#125; &#125; 其次：修改总的nginx的配置文件，让总的nginx文件包含我们自定义的项目的axfnginx.conf文件 总的nginx配置文件在：/etc/nginx/nginx.conf中 以上步骤操作完成以后，需要重启nginx： restart nginx```123456如果自定义的axfnginx.conf文件没有错误的话，查看nginx的运行状态会有如下的结果：active4.2 配置uwsgi文件在conf文件夹下除了包含自定义的axfnginx.conf文件，还有我们定义的uwsgi.ini文件 [uwsgi]projectname = axfbase = /home/src 守护进程master = true 进程个数processes = 4 虚拟环境pythonhome = /home/env/axfenv 项目地址chdir = %(base)/%(projectname) 指定python版本pythonpath = /usr/local/python3/bin/python3 指定uwsgi文件module = %(projectname).wsgi 和nginx通信地址:端口socket = 127.0.0.1:8890 日志文件地址logto = /home/logs/uwsgi.log`运行项目: uwsgi –ini uwsgi.ini","path":"2018/06/04/将django项目部署到CentOS服务器上/"},{"title":"Django分页，中间件，验证码使用指南","text":"django分页，中间件，验证码使用指南前言在django中提供了很多的插件功能，有利于开发者快速开发，比如中间件，分页器等 还提供了Pillow库，可以进行生成图片，用于登录的验证码图书设计。 1. 中间件Middleware中间件：a) 是一个轻量级的，底层的插件，可以介入Django的请求和响应的过程（面向切面编程) b) 中间件的本质就是一个python类 c) 面向切面编程(Aspect Oriented Programming)简称AOP，AOP的主要实现目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获取逻辑过程中各部分之间低耦合的隔离效果 思考： 什么是中间件？在settings.py中有很多的中间件，主要是用来做什么功能的呢，他们处理请求的url的过程在那些阶段呢，一般用来做那些数据的处理呢 1.1 中间件的处理函数123456789101112# __init__：没有参数，在服务器响应的第一个请求的时候自动调用，用户确定时候启动该中间件# process_request(self, request): 在执行视图前被调用，每个请求上都会被调用，不主动进行返回或返回HttpResponse对象# process_view(self, request, view_func,view_args, view_kwargs):调用视图之前执行，每个请求都会调用，不主动进行返回或返回HttpResponse对象# process_template_response(self, request, response)：在视图刚好执行完后进行调用，每个请求都会调用，不主动进行返回或返回HttpResponse对象# process_response(self, request, response):所有响应返回浏览器之前调用，每个请求都会调用，不主动进行返回或返回HttpResponse对象# process_exception(self, request, exception):当视图抛出异常时调用，不主动进行返回或返回HttpResponse对象 1.2 处理流程 1.3 自定义中间件流程a) 在工程目录下创建middleware目录 b) 目录中创建一个python文件 c) 在根据功能需求，创建切入需求类，重写切入点方法123456789from django.utils.deprecation import MiddlewareMixinclass AuthUserMiddleWare(MiddlewareMixin): def process_request(self, request): print(‘xxxx’) d) 启动中间件，在settings中进行配置，MIDDLEWARE中添加middleware.文件名.类名 2.分页2.1 分页库Paginator的基本语法django提供了分页的工具，存在于django.core中123# Paginator： 数据分页工具# Page：具体的某一页 Paginator：1#对象创建： Paginator(数据集，每一页数据) 属性：12345# count 计算和# num_pages: 页面总和# page_range: 页码列表，从1开始 方法： 1page(页码)：获取的一个page对象，页码不存在则抛出invalidPage的异常 2.2 常见错误123456# invalidPage：page()传递无效页码# PageNotAnInteger：Page()传递的不是整数# Empty:page()传递的值有效，但是没有数据 2.3 page对象page： 对象获取，通过Paginator的page()方法获得属性：1234# object_list: 当前页面上所有的数据对象# number： 当前页的页码值# paginator: 当前page关联的Paginator对象 方法：1234567# has_next() 判断是否有下一页# has_previous(): 判断是否有上一页# has_other_pages(): 判断是否有上一页或下一页# next_page_number(); 返回下一页的页码# previous_page_number(): 返回上一页的页码# len(): 返回当前也的数据的个数 2.4 Paginator对象和Page对象的关系如下有学生表，学生表中有25条数据，通过分页，每一个6条数据，去实现分页的功能 2.5 代码 3. 验证码在用户登录，注册以及一些敏感操作的时候，我们为了防止服务器被暴力请求，或爬虫爬取，我们可以使用验证码进行过滤，减轻服务器的压力。 验证码需要使用绘图Pillow1Pip install Pillow 核心：1image.ImageDraw.ImageFont 绘制流程：12345678910111213background = (10,20,30) RGB颜色# 初始化画布 image = Image.new(‘RGB’,(100,50), background)# 获取画布中画笔对象draw = ImageDraw.Draw(image, ‘RGB’)# 绘制验证码，随机四个# 导入字体文件path表示路径font = ImageFont.truetype(‘path’, size) fontcolor = (20,40,60)draw.text((x,y), ‘R’, font.fontcolor) x,y是文字左上角坐标","path":"2018/05/26/django分页，中间件，验证码使用指南/"},{"title":"Django使用自带的admin管理后台","text":"Django使用自带的admin管理后台前言Django框架是十分的强大的，利用其它框架，我们可能要自己去实现后台管理，但是Django直接就已经集成了管理后台，在管理后台中我们可以对自定义model进行CRUD操作，也能进行列表展示解析，分页等等 使用admin管理后台1.在model中定义Student的模型 123456class Students(models.Model): name = models.CharField(max_length=10) sex = models.BooleanField() class Meta: db_table = 'student' 2.配置admin管理后台的url 123# 在工程目录下可以看到路由配置中有一个admin的url地址url(r'^admin/', admin.site.urls), 3.创建admin后台的用户密码 在控制台使用命令1python manage.py createsuperuser 4.继承admin.ModelAdmin，编写自定义的admin 123456789101112# 在管理后台中操作模型对象。需要在app的admin.py中创建模型class StudentAdmin(admin.ModelAdmin): def set_sex(self): if self.sex: return '男' else: return '女' set_sex.short_description = '性别' list_display = ['id', 'name', set_sex] list_filter = ['sex'] search_fields = ['name'] list_per_page = 1 5.在登录后的管理后台注册 123# 在管理后台中操作模型对象。需要在app的admin.py中写如下代码admin.site.register(模型名) 或者使用装饰器实现注册123456789101112@admin.register(StudentAdmin)class StudentAdmin(admin.ModelAdmin): def set_sex(self): if self.sex: return '男' else: return '女' set_sex.short_description = '性别' list_display = ['id', 'name', set_sex] list_filter = ['sex'] search_fields = ['name'] list_per_page = 1","path":"2018/05/20/django使用自带的admin管理后台/"},{"title":"在Djnago当中restful风格的实现","text":"1. 修改响应的结构1.1 修改settings.py中的返回数据结构的配置信息 注意：定义default_renderer_classes参数，指定render的时候使用我们自定义的CustomJsonRender的类方法 1.2 重构JSONRenderer下的render方法该方法继承了JSONRenderer并且重构了render方法，修改了返回的数据结构 2. 异常的响应的结构自定义异常处理，一定需要继承from rest_framework.exceptions import APIException 中的APIException，在编写自己的异常处理的方法 3. PATCH请求，传入空置处理3.1 空置处理该patch请求中，我们想要修改id为3的学生的姓名，但是姓名我们传递一个空置，查看返回结果如下: 3.2 修改在serializer中定义s_name的序列化，指定错误的信息，为空的话，提示响应的错误信息 4. 页面异步提交api接口请求，并且在前端通过js刷新页面4.1. 创建实例4.1.1 后端业务逻辑处理创建url，定义register，创建serializer_class等 4.2 前端ajax请求get获取数据并刷新4.3 前端ajax请求delete删除数据 4.4 直接放入ajax更新删除获取信息的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;展示所有学生的信息&lt;/title&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/static/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&apos;#showStus&apos;).click(function()&#123; $.get(&apos;/stu/student/&apos;, function(msg)&#123; s = &apos;&lt;table&gt;&lt;tr&gt;&lt;td&gt;ID&lt;/td&gt;&lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;地址&lt;/td&gt;&lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;&apos; for(var i=0; i&lt;msg.length; i++)&#123; s += &apos;&lt;tr&gt;&lt;td&gt;&apos; + msg[i].id + &apos;&lt;/td&gt;\\ &lt;td&gt;&apos; + msg[i].s_name + &apos;&lt;/td&gt;\\ &lt;td&gt;&apos; + msg[i].s_tel + &apos;&lt;/td&gt;&lt;td&gt;\\ &lt;a href=&quot;javascript:;&quot; onclick=&quot;stu_update(&apos; + msg[i].id + &apos;)&quot;&gt;编辑&lt;/a&gt;|\\ &lt;a href=&quot;javascript:;&quot; onclick=&quot;del_stu(&apos; + msg[i].id + &apos;)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&apos; &#125; s += &apos;&lt;/table&gt;&apos; $(&apos;#div_stus&apos;).html(s) &#125;, &apos;json&apos;); &#125;); &#125;); function del_stu(i)&#123; csrf = $(&apos;input[name=&quot;csrfmiddlewaretoken&quot;]&apos;).val() $.ajax(&#123; url:&apos;/stu/student/&apos; + i, type:&apos;DELETE&apos;, headers:&#123;&apos;X-CSRFToken&apos;: csrf&#125;, dataType:&apos;json&apos;, success: function(msg)&#123; alert(&apos;删除成功&apos;); &#125;, error: function(msg)&#123; console.log(msg) &#125;, &#125;); &#125;; function stu_update(i)&#123; s = &apos;ID: &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&apos; + i + &apos;&quot;&gt;\\ 姓名:&lt;input type=&quot;text&quot; name=&quot;s_name&quot; id=&quot;s_name&quot;&gt; \\ 电话：&lt;input type=&quot;text&quot; name=&quot;s_tel&quot; id=&quot;s_tel&quot;&gt;\\ &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;update(&apos; + i + &apos;)&quot;&gt;&apos; $(&apos;#div_add&apos;).html(s) &#125;; function stu_add()&#123; s = &apos;姓名:&lt;input type=&quot;text&quot; name=&quot;s_name&quot; id=&quot;s_name&quot;&gt; \\ 电话：&lt;input type=&quot;text&quot; name=&quot;s_tel&quot; id=&quot;s_tel&quot;&gt;\\ &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;add()&quot;&gt;&apos; $(&apos;#div_add&apos;).html(s) &#125;;function update(i)&#123; csrf = $(&apos;input[name=&quot;csrfmiddlewaretoken&quot;]&apos;).val() s_name = $(&apos;#s_name&apos;).val() s_tel = $(&apos;#s_tel&apos;).val() $.ajax(&#123; url: &apos;/stu/student/&apos; + i + &apos;/&apos;, type: &apos;PATCH&apos;, dataType: &apos;json&apos;, headers:&#123;&apos;X-CSRFToken&apos;: csrf&#125;, data:&#123;&apos;s_name&apos;:s_name, &apos;s_tel&apos;:s_tel&#125;, success: function(msg)&#123; console.log(msg) &#125;, error: function(msg)&#123; console.log(msg) &#125;, &#125;);&#125;function add()&#123; csrf = $(&apos;input[name=&quot;csrfmiddlewaretoken&quot;]&apos;).val() s_name = $(&apos;#s_name&apos;).val() s_tel = $(&apos;#s_tel&apos;).val() $.ajax(&#123; url: &apos;/stu/student/&apos;, type: &apos;POST&apos;, dataType: &apos;json&apos;, headers:&#123;&apos;X-CSRFToken&apos;: csrf&#125;, data:&#123;&apos;s_name&apos;:s_name, &apos;s_tel&apos;:s_tel&#125;, success: function(msg)&#123; console.log(msg) &#125;, error: function(msg)&#123; console.log(msg) &#125;, &#125;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&#123;% csrf_token %&#125;&lt;input id=&quot;showStus&quot; value=&quot;获取所有学生的信息&quot; type=&quot;button&quot;&gt;&lt;/input&gt;&lt;div id=&quot;div_stus&quot;&gt;&lt;/div&gt;&lt;div id=&quot;div_add&quot;&gt;&lt;/div&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;stu_add()&quot;&gt;添加&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 5. 跨域请求5.1 什么是跨域同源：是指相同的协议、域名、端口，三者都相同才属于同源。 同源策略：浏览器处于安全考虑，在全局层面禁止了页面加载或执行与自身来源不同的域的任何脚本，站外其他来源的脚本同页面的交互则被严格限制。 跨域由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域 6. rest中的坑在实际的django项目中，我们经常需要使用到用户表，但是基于django提供的User表的字段有限，开发者一般都不会使用django提供的User模型，而自己创建User模型，并且基于登录注册的功能，也都会自己去实现，而不会使用django提供的登录注册功能。 重点坑:在我们使用自定义的User模型进行用户的登录以及注册的时候，我们使用自定义的中间件进行对用户进行验证，如果验证通过了，就将当前登录的用户User对象绑定在request中，即request.user = user。这个时候坑就出现了，当我们使用restframework去写api接口的时候，会出现权限认证错误，如下提示： 经过分析，可以判断是rest需要进行身份验证，所有我们在settings.py中设置rest的api接口不需要进行authentication的验证，具体配置如下：","path":"2018/05/18/在djnago当中restful风格的实现/"},{"title":"关于Restful指导原则的理解","text":"前言REST是所有Web应用都应该遵守的架构设计指导原则。 Representational State Transfer，翻译是”表现层状态转化”。 REST核心: 资源， 状态转移， 统一接口 资源: 是REST最明显的特征,是指对某类信息实体的抽象，资源是服务器上一个可命名的抽象概念，资源是以名词为核心来组织的，首先关注的是名词。 状态转移: 是指客户端痛服务端进行交互的过程中，客户端能够通过对资源的表述，实现操作资源的目的 统一接口: REST要求，必须通过统一的接口来对资源执行各种操作。对于每个资源只能执行一组有限的操作。 比如，客户端通过HTTP的4个请求方式(POST, GET, PUT, PATCH)来操作资源，也就意味着不管你的url是什么，不管请求的资源是什么但操作的资源接口都是统一的。 GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT(PATCH)用来更新资源，DELETE用来删除资源。 1. api定义规范1http://xxx.com/api/ 2. 资源在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 12345https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees 3. http请求方式123456789GET（SELECT）：从服务器取出资源（一项或多项）POST（CREATE）：在服务器新建一个资源PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）DELETE（DELETE）：从服务器删除资源 例子： 123456789101112131415GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 4. filter过滤12345?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件 5. 状态码服务端向用户返回请求api的结果，在结果中包含了status codes 状态码的，可以通过状态码去判断请求api的状态是成功还是失败 1234567891011121314151617181920212223200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 6. 错误处理如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: &apos;错误信息&apos;&#125; 7. django中使用restful1234pip install djangorestframeworkpip install django-filter # Filtering support 8. 简单的CRUD导入相关的信息： 1from rest_framework import mixins, viewsets CRUD对应的增删改查： 1234567增： POST http://127.0.0.1:8080/stu/addStu/删： DELETE http://127.0.0.1:8080/stu/addStu/1/改： UPDATE http://127.0.0.1:8080/stu/addStu/1/查： GET http://127.0.0.1:8080/stu/addStu/1/","path":"2018/05/15/关于Restful指导原则的理解/"},{"title":"Django中模型的设计","text":"前言​ Django对数据库提供了很好的支持，对不同的数据库,django提供了统一调用的API，我们可以根据不同的业务需求使用不同是数据库。Django中引入了ORM(Objects Relational Mapping)对象关系映射，是一种程序技术。在下面会详细的讲解。 1.定义模型重要概念：模型，表，属性，字段一个模型类在数据库中对应一张表，在模型类中定义的属性，对应模型对照表中的一个字段 创建学生模型类12345678910class Student(models.Model): s_name = models.CharField(max_length=10) s_age = models.IntegerField() s_gender = models.BooleanField() class Meta: db_table = 'cd_student' ordering =[] 对象的默认排序字段，获取对象列表时使用，升序ordering['id']，降序ordering['-id'] 2.ORMORM(Objects Relational Mapping)对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。可以简单理解为翻译机。 3. 模型查询a) 模型成员objectsDjango默认通过模型的objects对象实现模型数据查询 b) 过滤器查询集表示从数据库获取的对象集合 查询集可以有多个过滤器 过滤器就是一个函数，基于所给的参数限制查询的结果 1234567从SQL角度来说，查询集合和select语句等价，过滤器就像where条件Django有两种过滤器用于筛选记录 filter : 返回符合筛选条件的数据集 exclude : 返回不符合筛选条件的数据集 多个filter和exclude可以连接在一起查询 当然还有如下这些过滤器: 123456789all() 返回所有数据filter() 返回符合条件的数据exclude() 过滤掉符合条件的数据order_by() 排序values() 一条数据就是一个字典，返回一个列表 c) 查询单个数据get()：返回一个满足条件的对象。如果没有返回符合条件的对象，会应该模型类DoesNotExist异常，如果找到多个，会引发模型类MultiObjectsReturned异常 first()：返回查询集中的第一个对象 last()：返回查询集中的最后一个对象 count()：返回当前查询集中的对象个数 exists()：判断查询集中是否有数据，如果有数据返回True，没有返回False d) 限制查询集限制查询集，可以使用下表的方法进行限制，等同于sql中的limit 模型名.objects.all()[0:5] 小标不能为负数 e) 字段查询对sql中的where实现，作为方法，filter(),exclude()，get()的参数 语法：属性名称__比较运算符 = 值 外键：属性名_id 注意：like语句中使用%表示通配符。比如sql语句查询 where name like ‘%xxx%’，等同于filter(name_contains=’xxx’) f) 比较运算符contains：是否包含，大小写敏感 startswith，endswith：以values开头或者结尾，大小写敏感 以上的运算符前加上i(ignore)就不区分大小写了 isnull，isnotnull：是否为空。filter(name__isnull=True) in：是否包含在范围内。filter(id__in=[1,2,3]) gt，gte，lt，lte：大于，大于等于，小于，小于等于。filter(age__gt=10) pk：代表主键，也就是id。filter(pk=1) g) 聚合函数agregate()函数返回聚合函数的值 Avg：平均值 Count：数量 Max：最大 Min：最小 Sum：求和 例如: Student.objects.aggregate(Max(‘age’)) h) F对象/Q对象F对象:可以使用模型的A属性与B属性进行比较 背景:在模型中有两个字段，分别表示学生成绩A与成绩B，要对成绩AB进行比较计算，就需要使用到F对象。 例如有如下例子1: 123班级中有女生个数字段以及男生个数字段，统计女生数大于男生数的班级可以如下操作:grades = Grade.objects.filter(girlnum__gt=F(&apos;boynum&apos;)) F对象支持算数运算 grades = Grade.objects.filter(girlnum__gt=F(‘boynum’) + 10) 例子2： 123456查询python班下语文成绩超过数学成绩10分的学生 grade = Grade.objects.filter(g_name=&apos;python&apos;).first() students = grade.student_set.all() stu = students.filter(s_yuwen__gt= F(&apos;s_shuxue&apos;) + 10) Q对象: Q()对象就是为了将过滤条件组合起来 当我们在查询的条件中需要组合条件时(例如两个条件“且”或者“或”)时。我们可以使用Q()查询对象 使用符号&amp;或者|将多个Q()对象组合起来传递给filter()，exclude()，get()等函数 Q()对象的前面使用字符“~”来代表意义“非” 例子1: 查询学生中不是12岁的或者姓名叫张三的学生 1student = Student.objects.filter(~Q(age=12) | Q(name=&apos;张三&apos;)) 例子2： 查询python班语文小于80并且数学小于等于80的学生 123grade = Grade.objects.filter(g_name=&apos;python&apos;).first()students = grade.student_set.all()stu = students.filter(~Q(s_yuwen__gte=80) &amp; Q(s_shuxue__lte=80)) 例子3： 查询python班语文大于等于80或者数学小于等于80的学生 1234grade = Grade.objects.filter(g_name=&apos;python&apos;).first()students = grade.student_set.all()stu = students.filter(Q(s_yuwen__gte=80) | Q(s_shuxue__lte=80)) 4.模型字段定义属性定义属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109概述 ·django根据属性的类型确定以下信息 ·当前选择的数据库支持字段的类型 ·渲染管理表单时使用的默认html控件 ·在管理站点最低限度的验证 ·django会为表增加自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后，则django不会再生成默认的主键列 ·属性命名限制 ·遵循标识符规则(不使用python预定义的标识符号，内置函数名，异常等。避免使用下划线等) ·由于django的查询方式，不允许使用连续的下划线库 ·定义属性时，需要字段类型，字段类型被定义在django.db.models.fields目录下，为了方便使用，被导入到django.db.models中 ·使用方式 ·导入from django.db import models ·通过models.Field创建字段类型的对象，赋值给属性逻辑删除 ·对于重要数据都做逻辑删除，不做物理删除，实现方法是定义isDelete属性，类型为BooleanField，默认值为False字段类型 ·AutoField ·一个根据实际ID自动增长的IntegerField，通常不指定如果不指定，一个主键字段将自动添加到模型中 ·CharField(max_length=字符长度) ·字符串，默认的表单样式是 TextInput ·TextField ·大文本字段，一般超过4000使用，默认的表单控件是Textarea ·IntegerField ·整数 ·DecimalField(max_digits=None, decimal_places=None) ·使用python的Decimal实例表示的十进制浮点数 ·参数说明 ·DecimalField.max_digits ·位数总数 ·DecimalField.decimal_places ·小数点后的数字位数 ·FloatField ·用Python的float实例来表示的浮点数 ·BooleanField ·true/false 字段，此字段的默认表单控制是CheckboxInput ·NullBooleanField ·支持null、true、false三种值 ·DateField([auto_now=False, auto_now_add=False]) ·使用Python的datetime.date实例表示的日期 ·参数说明 ·DateField.auto_now ·每次保存对象时，自动设置该字段为当前时间，用于&quot;最后一次修改&quot;的时间戳，它总是使用当前日期，默认为false ·DateField.auto_now_add ·当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为false ·说明 ·该字段默认对应的表单控件是一个TextInput. 在管理员站点添加了一个JavaScript写的日历控件，和一个“Today&quot;的快捷按钮，包含了一个额外的invalid_date错误消息键 ·注意 ·auto_now_add, auto_now, and default 这些设置是相互排斥的，他们之间的任何组合将会发生错误的结果 ·TimeField ·使用Python的datetime.time实例表示的时间，参数同DateField ·DateTimeField ·使用Python的datetime.datetime实例表示的日期和时间，参数同DateField ·FileField ·一个上传文件的字段 ·ImageField ·继承了FileField的所有属性和方法，但对上传的对象进行校验，确保它是个有效的image字段选项 ·概述 ·通过字段选项，可以实现对字段的约束 ·在字段对象时通过关键字参数指定 ·null ·如果为True，则该字段在数据库中是空数据，默认值是 False ·blank ·如果为True，则该字段允许为空白，默认值是 False ·注意 ·null是数据库范畴的概念，blank是表单验证证范畴的 ·db_column ·字段的名称，如果未指定，则使用属性的名称 ·db_index ·若值为 True, 则在表中会为此字段创建索引 ·default ·默认值 ·primary_key ·若为 True, 则该字段会成为模型的主键字段 ·unique ·如果为 True, 这个字段在表中必须有唯一值","path":"2018/05/12/Django中模型的设计/"},{"title":"Django中模型的关系设计(一)","text":"前言​ 该文档中主要介绍模型的对应关系，一对一，一对多，以及多对多的关系。并且举例说明 模型对应关系描述如下： 1：1 一对一 OneToOneField 1：N 一对多 ForeignKey M：N 多对多 ManyToManyField 常见的几种数据关系，django都提供了很好的支持。 1. 一对一1.1 模型123456789101112131415161718192021222324创建学生的模型：class Student(models.Model): stu_name = models.CharField(max_length=6, unique=True) stu_sex = models.BooleanField(default=0) stu_birth = models.DateField() stu_delete = models.BooleanField(default=0) stu_create_time = models.DateField(auto_now_add=True) stu_operate_time = models.DateField(auto_now=True) stu_tel = models.CharField(max_length=11) stu_yuwen = models.DecimalField(max_digits=3, decimal_places=1, default=0) stu_shuxue = models.DecimalField(max_digits=3, decimal_places=1, default=0) class Meta: db_table = &apos;stu&apos;创建学生拓展的模型：class StuInfo(models.Model): stu_addr = models.CharField(max_length=30) stu_age = models.IntegerField() stu = models.OneToOneField(Student) class Meta: db_table = &apos;stu_info&apos; 1234使用models.OneToOneField()进行关联class StuInfo(models.Model):下是通过班级获取学生信 stu = models.OneToOneField(Student)注意：在数据中关联字段名称叫stu_id 1.2 通过学生拓展表去获取学生信息1​ stuinfo = StuInfo.objects.all().first() student = stuinfo.stu ​12注意：通过拓展表去获取学生的信息的话，语法如下； 学生拓展表的单条对象.关联字段，即可获取到学生表的数据 1.3 通过学生获取人信息11​ stu = Student.objects.all().first() stuInfo = stu.stuInfo ​12注意：通过学生获取关联表的数据的话，语法如下： 学生对象.关联的表名，即可获取到关联表的数据 1.3.1 通过学生获取人信息212在关联字段OneToOneField中加入参数related_name=&apos;xxx&apos;​ 在 stu = Student.objects.all().first() stuInfo = stu.xxx ​12注意：通过学生获取关联表的数据的话，语法如下： 学生对象.关联的字段中定义的related_name参数，即可获取到关联表的数据 1.4 设置对应关系的字段为保护模式 :12345678models.CASCADE 默认值models.PROTECT 保护模式models.SET_NULL 置空模式models.SET_DETAULT 置默认值models.SET() 删除的时候吃重新动态指向一个实体访问对象元素on_delete = models.PROTECT​ 修改on_delete参数models.OneToOneField(‘Student’, on_delete=models.SET_NULL, null=True)​12在删除student对象的时候，stuinfo的关联字段会设置为空null=True，如下命令去删除student的数据：​ Student.objects.filter(id=1).delete()​12 1.5 定义on_delete=models.PROTECT1234p = Student.objects.all().first()p.delete()注意：这个时候去执行该业务逻辑的方法的时候会报错 2. 一对多2.1 模型1​ 定义一个班级类还有学生类，实现一对多的关系： 先定义班级类 Class Grade(models.Model): g_name = models.CharField(max_length=16) 定义student class Student: s_name = models.CharField(max_length=10) s_age = models.IntegerField(default=1) s_grade = models.ForeignKey(Grade, on_delete=PROTECT) ​12 注意：使用models.ForeignKey关联 获取对象元素 grade.student_set 2.2 获取数据语法：通过一获取多的数据 公式： 一的对象.多的模型_set 然后在获取数据all(), get(), filter() 等等 如下先通过学生去获取班级信息： 12stu = Student.objects.first()stu.stu_grade 如下是通过班级获取学生信息： 12g = Grade.objects.all().first()g.stugrade.all() ---&gt; 其中stugrade是定义的related_name参数 重点： 定义了related_name字段以后，只能通过related_name去反向获取数据，在也不能通过_set方法去获取数据了 2.3 性能对比12获取班级的学生(通过一获取多)​ 1. 低性能方法： g = Grade.objects.all().first() s = Student.objects.filter(s_grade=g) 2. 高性能方法： g = Grate.objects.all().first() s = g.student_set.all() ​12 2.4 练习题2.6 获取python班下的所有学生的信息12gs = Grade.objects.filter(g_name=&apos;python&apos;)[0]allstu = gs.student_set.all() 2.7 获取python班下语文成绩大于80分的女学生12gs = Grade.objects.filter(g_name=&apos;python&apos;)[0]allstu = gs.student_set.filter(stu_yuwen__gte=80) 2.8 获取python班下语文成绩超过数学成绩10分的男学生12gs = Grade.objects.filter(g_name=&apos;python&apos;)[0]allstu = gs.student_set.filter(stu_yuwen__gte=F(&apos;stu_shuxue&apos;) + 10) 2.9 获取出生在80后的男学生，查看他们的班级12gs = Grade.objects.filter(g_name=&apos;python&apos;)[0]allstu = gs.student_set.filter(stu_birth__gte=&apos;1980-01-01&apos;, stu_birth__lte=&apos;1990-01-01&apos;) 3. 多对多3.1 M:N 模型定义购物车，用户的例子实现多对多：\\创建用户模型: class GoodsUser(models.Model): u_name 12 2. 创建商品模型: class Goods(models.Model): g_name = models.CharField(max_length=32) g_user = models.ManyToManyField(User) ​12 3.2 多对多表结构123456多对多关系：1. 生成表的时候会多生成一张表（实际会有三张表）2. 生成的表是专门用来维护关系的3. 生成的表是使用两个外键来维护多对多的关系4. 两个一对多的关系来实现多对多的实现 5. 删除一个表的数据的话，中间关联表也要删除相关的信息 3.3 练习题3.3.1 获取第一个用户购买了那些商品1​ gu = GoodsUser.objects.all().first() allstu = gu.goods_set.all() ​12 3.3.2 获取指定商品的购买用户信息1​ g = Goods.objects.filter(id=1)[0] g.g_user.all() ​","path":"2018/05/12/Django中模型的关系设计/"},{"title":"windows下如何一步一步搭建Django项目","text":"1.安装虚拟环境​ 首先，要确保的是你的电脑已经安装了Python和pip包，如果没有安装，那么请移步百老师将Python环境搭建好！有了Python环境后，接下来我们就正式安装虚拟环境了。 ​ 为什么要安装虚拟环境呢？ 首先是每个项目所需要的环境不一样，如果我们每个项目都使用一个环境，那么环境必然是复杂臃肿的，其次，某些项目需要不同的版本，比如Python2、Python3和Django1.x、Django2.x等。 ​ 好了，正式开始！ 123456789101112# 1、安装virtualenv# 进入cmd终端pip install virtualenv# 2、查看安装的virtualenv版本及help帮助选项# 其中需要注意的是-p 和 --no-site-packages 这两个参数# -p是选择使用什么本地Python版本，--no-site-packages是不依赖安装其他包，值安装纯净的python虚拟环境virtualenv --versionvirtualenv --help# 3、安装虚拟环境virtualenv --no-site-packages djangoenv（虚拟环境名字） 2.创建Django项目​ 通过上面的步骤我们已经拥有了一个纯净的Python虚拟环境了，接下来就是创建Django项目了。 12345678910# 1、进入虚拟环境cd djangoenv/Scriptsactivate # 进入虚拟环境deactivate # 退出虚拟环境# 2、安装Djangopip install django==版本号 # 指定版本# 3、去到要创建Django项目的位置cd xxx# 4、创建Django项目django-admin startproject xxx(Django项目名) 至此，一个Django项目就已经创建好了，然后接下来我们就要实现功能，实现功能需要在app当中来实现，下一步就是创建app了。 3.创建app1python manage.py startapp xxx（app名） 通过以上步骤，我们就完成了Django项目的创建，项目目录如下图： manage.py： 是Django用于管理本项目的管理集工具，之后站点运行，数据库自动生成，数据表的修改等都是通过该文件完成。 项目文件夹下共有5个顶级文件：主项目文件夹shop_market、APP文件夹xfmart、静态文件夹static、模板文件夹templates、项目管理manage.py文件。 init.py： 指明该目录结构是一个python包，暂无内容，在后期会初始化一些工具会使用到。 seetings.py： Django项目的配置文件，其中定义了本项目的引用组件，项目名，数据库，静态资源，调试模式，域名限制等 urls.py：项目的URL路由映射，实现客户端请求url由哪个模块进行响应。 wsgi.py：定义WSGI接口信息，通常本文件生成后无需改动 4.setting配置配置installed_apps配置，templates配置，数据库，时区， 静态的static 1234567891011121314151617181920212223242526272829303132# 1.在INSTALLED_APPS里加入创建的appINSTALLED_APPS = [ '''' 'xxx'(app名)]# 2.tempaltes模板设置TEMPLATES = [ '''''' 'DIRS':[os.path.join(BASE_DIR, 'templates')],]# 3.数据库设置（连接mysql，其他数据库大致相同）DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'xfmarket', 'HOST': '数据库主机地址', 'PORT': '3306', 'USER': '用户名', 'PASSWORD': '密码' &#125;&#125;# 4.时区及语言LANGUAGE_CODE = 'zh-hans'TIME_ZONE = 'Asia/Shanghai'# 5.static文件和media文件路径配置STATIC_URL = '/static/'STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 5.启动项目经过一番设置创建，我们的Django项目就创建完成了，接下来就是启动项目了。 12# 在黑屏终端输入python manager.py runserver 至此，Django项目就启动成功了！","path":"2018/05/11/如何一步一步搭建Django项目/"},{"title":"Django初识","text":"1.Django简介：Django发布于2005年7月，是当前Python世界里最有名且成熟的网络框架。 最初是被开发用于管理劳伦斯出版集团旗下的以新闻内容为主的网站的，即CMS(内容管理系统)软件。 Django是一个用Python编写的开放源代码的Web应用框架，代码是开源的。此系统采用了MVC的框架模式, 也可以称为MTV模式 具体介绍详见Django官网 2.什么是MVCMVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 通俗的来讲就是，强制性的使应用程序的输入，处理和输出分开。通过控制器，将数据和显示分离，好处是同一个视图可以加载不同的模型，同一个模型也可以显示成不同的视图稍具规模的系统都会使用MVC架构或者它的变体（MVP、MVVM等）。 它是对面向对象设计原则中迪米特法则的一个最好的践行 核心思想：解耦 优点：减低各个模块之间的耦合性，方便变更，更容易重构代码，最大程度的实现了代码的重用 MVC(Model, View, Controller) Model: 即数据存取层。用于封装于应用程序的业务逻辑相关的数据，以及对数据的处理。说白了就是模型对象负责在数据库中存取数据 View: 即表现层。负责数据的显示和呈现。渲染的html页面给用户，或者返回数据给用户。 Controller: 即业务逻辑层。负责从用户端收集用户的输入，进行业务逻辑处理，包括向模型中发送数据，进行CRUD操作。 3.Django的模式简介严格来说，Django的模式应该是MVT模式，本质上和MVC没什么区别，也是各组件之间为了保持松耦合关系，只是定义上有些许不同。 Model： 负责业务与数据库(ORM)的对象 View： 负责业务逻辑并适当调用Model和Template Template: 负责把页面渲染展示给用户 注意： Django中还有一个url分发器，也叫作路由。主要用于将url请求发送给不同的View处理，View在进行相关的业务逻辑处理。 参考文章：DJANGO使用指南 作者：王海飞","path":"2018/05/10/Django的初识/"},{"title":"关于Django无法加载media文件里的静态文件问题解决方法","text":"第一种配置第一步、在setting里加入如下配置123456STATIC_URL = '/static/'STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 第二步、在项目urls下加入以下配置开头引入以下包 12from django.contrib.staticfiles.urls import staticfrom stu_ms.settings import MEDIA_ROOT, MEDIA_URL 末尾加入 1urlpatterns += static(MEDIA_URL, document_root=MEDIA_ROOT) 第二种配置第一步、在settings.py文件的最后加上以下内容:12345678910STATIC_URL = ‘/static/’ STATIC_ROOT = os.path.join(BASE_DIR, ’static’)# 设置图片等静态文件的路径STATICFILES_DIRS = ( (‘css’,os.path.join(STATIC_ROOT,’css’).replace(‘\\’,’/’) ), (‘js’,os.path.join(STATIC_ROOT,’js’).replace(‘\\’,’/’) ), (‘images’,os.path.join(STATIC_ROOT,’images’).replace(‘\\’,’/’) ), (‘upload’,os.path.join(STATIC_ROOT,’upload’).replace(‘\\’,’/’) ), ) 第二步、在项目urls下加入以下配置开头引入以下包 123from django.contrib.staticfiles.urls import staticfiles_urlpatternsfrom django.contrib import staticfiles 末尾加入 1urlpatterns += staticfiles_urlpatterns() 至此，关于django无法加载media文件夹里的静态文件的问题就能够解决了，如若还不能解决，请尝试网管三绝招！","path":"2018/05/09/关于django无法加载media文件里的静态文件问题解决方法/"},{"title":"CentOS7.2下安装MySQL5.7","text":"CentOS7.2 安装mysql5.7初始密码问题总结CentOS 7之后的版本yum的默认源中使用MariaDB替代原先MySQL。这对于想要使用MySQL的朋友来说，安装MySQL就比较麻烦了，笔者看了网上很多的教程，感觉不是很友好，幸运的是经过几天的摸索，笔者终于成功的装上了MySQL，现将安装的经验总结如下。 1、下载mysql的源1wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz ###2、创建组、用户 建立用户mysql，组mysql。后面mysql就使用这个用户来运行（注意这也是mysql启动脚本中默认的用户，因此最好不要改名）。groupadd mysqluseradd -r -g mysql mysql - （使用-r参数表示mysql用户是一个系统用户，不能登录） 3、安装3.1 解压将前面得到的mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz 解压、解归档gunzip mysql-5.7.22-linux-glibc2.12-x86_64.tar.gztar -xvf mysql-5.7.22-linux-glibc2.12-x86_64.tar将解压后的目录移动至 /usr/local ，并重命名为 mysqlmv mysql-5.7.22-linux-glibc2.12-x86_64 /usr/local/mysql此后 /usr/local/mysql 就是安装目录了注意，如果mysql目录下没有data和tmp目录，手动新建，并修改权限 3.2 目录权限设置将mysql及其下所有的目录所有者和组均设为mysql:cd /usr/local/mysqlchown mysql:mysql -R . 3.3 初始化123456789/usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql# 初始化成功后出现如下信息：201x-xx-xxT07:10:13.583130Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).201x-xx-xx T07:10:13.976219Z 0 [Warning] InnoDB: New log files created, LSN=45790201x-xx-xx T07:10:14.085666Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.201x-xx-xx T07:10:14.161899Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 1fa941f9-effd-11e5-b67d-000c2958cdc8.201x-xx-xx T07:10:14.165534Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened.201x-xx-xx T07:10:14.168555Z 1 [Note] A temporary password is generated for root@localhost: xxxxxxxxx, # 注意最后一行，它给了root一个初始密码，后面要登录的时候要用到这个密码。 3.4 配置配置 /etc 下的 my.cnf 文件，如果没有请创建 12345678910[mysqld]basedir = /usr/local/mysqldatadir = /usr/local/mysql/dataport = 3306socket = /usr/local/mysql/tmp/mysql.sock sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[client]socket = /usr/local/mysql/tmp/mysql.sock 4、后台运行服务端1234注意：请将&#123;mysql&#125; 替换成 mysql安装路径&#123;mysql&#125;/bin/mysqld_safe &amp;ps -ef | grep mysql 或者 netstat -nap | grep 3306 - 查看进程&#123;mysql&#125;/bin/mysqladmin -uroot -p - 停止 5、设置mysql以服务运行并且开机启动将{mysql}/ support-files/mysql.server 拷贝为/etc/init.d/mysql并设置运行权限 1234567cp mysql.server /etc/init.d/mysqlchmod +x /etc/init.d/mysql# 把mysql注册为开机启动的服务chkconfig --add mysql# 当然也可以手动进行服务的开启和关闭：/etc/init.d/mysql start/etc/init.d/mysql stop 6、连接客户端1234567891011121314151617# 将客户端软链接到 /usr/local/binln -s &#123;mysql&#125;/bin/mysql /usr/local/bin/mysql# 客户端连接mysql -u root -p# 输入刚才的初始化密码进入# 进入之后，修改密码mysql&gt; alter user 'root'@'localhost' identified by 'xxxxxxx';# 配置远程可以连接use mysql # 打开mysql数据库 # 将host设置为%表示任何ip都能连接mysql，当然也可以将host指定为某个ip update user set host='%' where user='root' and host='localhost'; flush privileges; #刷新权限表，使配置生效 关闭远程连接，恢复mysql的默认设置（只能本地连接）# 将host设置为localhost表示只能本地连接mysql update user set host='localhost' where user='root'; # 也可以添加一个用户名为aaa，密码为xxx，权限为%（表示任意ip都能连接）的远程连接用户grant all on *.* to 'aaa'@'%' identified by 'xxx';","path":"2018/05/03/CentOS7-2下安装MySQL5-7/"},{"title":"Python的基本语法整理","text":"Python的基础语法知识整理集合收集整理了Python的基础语法，包括数据类型的详细解释和Python自带的各类模块 1. 进制之间的转换二进制 -&gt; 十进制八进制 -&gt; 二级制十进制 -&gt; 二进制 2.逻辑运算符逻辑运算符与(and) 或(or) 非(not) 3.数学函数abs(): 返回数字的绝对值max(): 返回给定参数中的最大值min():返回给定参数中最小的值pow(): 求幂(求次方) [求3^4 print(3**4) print(pow(3, 4))]round():四舍五入,如果只有一个参数,默认不保留小数点.参数二: 小数点后保留的位数 import mathmath.ceil():向上取整math.floor():向下取整math.sqrt():求开方math.modf():返回参数的整数部分和小数部分 import randomrandom.choice():返回列表,元祖,字典中的某一个值random.choices():返回列表,元祖,字典中的指定个数值个值 k 关键字参数random.random():返回0-1之间的数, [0, 1)random.uniform():返回指定的一个区间范围的随机数 [, )random.randint():返回指定区间范围的随机整数 [, ]random.shuffle():将列表中的数据进行打乱排序 4. 字符串len():求字符串,元组,列表,字典,集合的长度split():通过指定分隔符对字符串进行切片str1 3 (将字符串拼接n次) 提取某个字符串 str1[::3] 正序输出 步长为3 str2 = str1[::-1] 倒序输出 str2 = str1[::-2] 倒序输出 步长为2转义字符: \\t(制表符) \\n(换行符) 5.字符串格式化%s: 给字符串站位%d: 给int类型站位%f: 给浮点类型站位, 默认保留6为小数 %.2f: 保留两位小数 %10.2f 共10位,保留两位小数,其他为使用空格补齐 %010.2f 共10位,保留两位小数,其他为使用0补齐 %c: 打印一个字符%o: 将十进制转换成八进制%x: 将十进制转换成十六进制 6.字符串比较大小从第一个字符开始比较,将字符转换成ascii值进行比较如果小于则返回True,否则返回False0-9:48-57a-z: 97-122A-Z:65-90 附: 字符串相关函数 7.表达式表达式为真的情况: not 0 -1 为真表达式为假的情况: 0 ‘’ None False [] () {} 8.列表列表函数: append()往列表后边追加一个元素([1, 2 ,3],当做一个元素追加到列表中) # 没有add()方法 extend()在末尾一次性追加另外一个列表中的多个值([1, 2 ,3],当做三个个元素追加到列表中) insert():在指定下标出添加一个元素,原来位置处的元素往后移动list.insert(下标, 对象) pop():将列表中指定下标的元素删除, 如果默认不传递参数,则删除的是最后一个元素@参数一: [可有可无] 列表对应的下标 remove():移除列表中指定的元素@参数一: 列表中的元素 clear():清除列表中所有的元素 index():获取列表元素锁对应的下标 @参数一: 列表中的某一个元素 返回值: 列表中元素所对应的下标 count(): 计算列表中元素出现的次数 reverse(): 用于反向列表中元素 等同于[::-1]reversed(seq) 函数返回一个反转的迭代器。seq – 要转换的序列，可以是 tuple, string, list 或 range。 sort(): 应用在 list 上的方法, 返回的是对已经存在的列表进行操作sort(self, key=None, reverse=False)sorted(): 所有可迭代的对象进行排序操作, 返回的是一个新的 list，而不是在原来的基础上进行的操作。sorted(iterable, key=None, reverse=False) reverse = True 降序 , reverse = Flase 升序(默认) 引用传递 在列表中,如果修改一个列表的元素,那么对应的另外一个列表的元素也改变list14 = [2, 3, 4]list15 = list14 # 内存地址相同 值传递 在列表中修改一个元素的值时,对应的另外一个列表中的值是不发生改变的list16 = [1, 2, 3, 4]list17 = list16[:] # 内存地址不同list17 = list16.copy() # 内存地址不同 9.元组有序集合, 不可修改创建一个空的元组 tupel1 = ()tuple1 = (4, ) # 定义只有一个参数的元组 10.字典无序集合, key唯一,必须是不可变类型访问获取方式: dict[key] dict.get(key) 添加元素: dict[key] = value # key为原字典中不存在的键修改: dict[key] = balue # key为原字典中存在的键dict.keys() 以列表返回字典中所有的键dict.values() 以列表返回字典中所有的值dict.items() 以列表返回可遍历的(键, 值) 元组数组dict.setdefault() 返回指定键的值,如果键不存在于字典中，将会添加键并将值设为默认值dict.pop([key]) 删除指定键值对, 需传入参数 # 没有remove()方法enumerate()用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 11.set 集合1.set是无序2.set集合是不可改变的3.创建一个空的集合 set1 = set(());set1 = set([]);set1 = set({})set.add(): 增加一个元素(重复元素不能添加) # 没有append()方法set.remove():删除元素, 参数是元素set.pop():删除最后一个元素set1 &amp; set2 交集set1 | set2 并集set1 - set2 差集set1 ^ set2 交并集 12.数据类型转换dict-&gt;set 取字典的键, 传入集合set3 = {‘a’:1, ‘b’:2, ‘c’:3} 这是一个字典set –&gt; dict(错误) # 不能将集合转换成字典, 只有键, 没有值 13.函数参数 不定长参数: *args 关键字参数: **kw 匿名函数: 关键字 lambda eg: sum = lambda x: x ** x 偏函数: 导入模块 import functoolsfunctools.partical()就是创建一个新的函数.不需要自行定义函数.直接将结果赋值给一个变量,而 这个变量就是一个函数.这个函数的目的是将默认参数给固定住 回调函数: 定义函数时,将函数名作为参数传递过来,然后在函数里边再次调用函数 14.文件操作Python3 File(文件)方法open(path_name[, mode[, buffering]]) 打开文件 参数二:默认只读fileObject.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。fileObject.write() 写文件 # 如果要写入字符串以外的数据,先将他转换为字符串fileObject.close() 关闭文件fileObject.readline([size]) 读取整行内容,包括\\n字符, 如果给定参数则从文件开始读取指定的字符个数fileObject.readlines([sizeint]) 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。f.tell() 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).f.seek(偏移量,[起始位置]) 用来移动文件指针 #偏移量:单位:比特,可正可负起始位置:0-文件头,默认值;1-当前位置;2-文件尾for line in f: print(line) 通过迭代器访问with open(pathname, mode) as f​示列详见菜鸟教程Python3 File(文件)方法http://www.runoob.com/python3/python3-file-methods.html StringIOfrom io import StringIOf = StringIO([str]) 初始化, 然后像file一样读写在内存中读写str, 使用StringIO会比在文件中操作内容速度快 ByteIOfrom io import BytesIOf = ByteIO([b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’]) 初始化,然后像文件一样读写在内存中读写二进制数据 总结 ：StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。 模式 r r+ w w+ a a+ 读 + + + + 写 + + + + + 创建 + + + + 覆盖 + + 指针在开始 + + + + 指针在结尾 + + Python OS 文件/目录方法os.getcwd() 返回当前的工作目录 # 获取绝对路径os.listdir(path) 返回指定的文件夹包含的文件或文件夹的名字的列表os.mkdir(path) 在当前目录下创建新的目录os.rmdir(path) 删除目录, 只能删除空目录os.rename(src, dst) 对文件进行重命名os.stat(file) 获取文件属性os.remove(file) 删除文件 #可以将本文件删除os.path.join(path1, path2) 路径拼接os.path.split(path) 拆分路径 # 返回一个元组(目录, 最后一个文件/目录名称)os.path.splitext(path) 获取文件的或站名os.path.exists(path) 判断文件/目录是否存在os.path.isfile(path) 判断是否是文件os.path.getsize(file) 获取文件的大小os.path.dirname(path) 获取当前文件的目录os.path.basename(path) 获取当前文件/目录名示列网址:http://www.runoob.com/python/os-file-methods.html 15.作用域一旦在函数内部设置为global,则该变量全局有效 16.装饰器本质还是函数, 一般使用装饰器来装饰其他函数.本身还是函数的调用@property@属性名.setter广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。 17.日期和时间time(时间)time.localtime() 获取本地时间time.asctime() / time.ctime() 将时间转换成用户可读时间, 返回str格式 (Thu Apr 19 23:02:35 2018)time.strftime(‘%Y-%m-%d %X’) 字符串的格式化输出, 返回str格式 2018-04-19 23:07:51time.strptime(timeObject, ‘%Y-%m-%d %X’) # 将字符串的时间格式转换成元祖类型的时间格式 datetime(日期)datetime.datetime.now() 获取当前时间datetime.datetime(2020, 2, 2, 20, 20, 20) 获取指定的时间date1.strftime(‘%Y-%m-%d %X’) 时间字符串的格式化输出, 返回str格式 calendar(日历)calendar.month(2018, 4) 获取指定的月份日历calendar.calendar(2018) 获取指定的年份日历 更多时间日期方法想见网址:http://www.runoob.com/python/python-date-time.html csv文件csv是跨多种形式的导入导出的标准格式 比如: mysql excel它是一种一纯文本形式来存储数据.文件中的每一行代表一条数据.每条记录包含逗号分隔 18.部分模块import keyword 标志符 查看所有关键字import functools 偏函数import collections collections.deque方法可以创建一个两端都可以操作的列表,也就是说我们可以在两端进行添加和删除 from types import MethodType MethodType() 动态添加方法到类或对象实例中","path":"2018/04/26/Python的基本语法整理/"},{"title":"Git版本控制软件的操作","text":"Git — 版本控制 分布式版本控制系统 - 社会化编程GitBitMove - BitKeeper 集中式版本控制系统 - 版本控制服务器锁定模式 CVS - Concurrent Version System VSS - Visual Source Safe ClearCase - IBM - Rational合并模式 Sunversion - SVN git命令git –version 查看git版本 设置全局配置 – 身份信息 git config –global user.name ‘Zoie1996’ git config –global user.email &#39;18086869080@163.com‘ git init –&gt; /Users/GavinLiu/Desktop/hello/.git/ 初始化 自动创建一个隐藏文件夹 add 放入暂存区 git add [file] 把文件添加到版本控制 get add . 把当前路径下所有东西纳入版本控制 commit 提交到本地仓库 - 本地隐藏文件夹 git commit -m ‘创建日历文件’ 将文件放到仓库, 写明更新原因 git status 查看放在暂存区的文件状态 git checkout – 撤回所有暂存区文件git checkout – [file] 撤回暂存区文件 git log 查看历史版本git log –pretty=oneline 单行显示get reflog 查看版本包括未来版本 git reset –hard [版本代号前6位] 返回任何一个版本 远端代码下载 git clone [url] 将远端仓库(代码托管平台)代码克隆到本地 git push origin master 将本地项目推送到服务器 origii-默认(项目在服务器的一个别名) master-主干 git branch [分支file] 创建分支名 git branch 查看分支 git checkout [分支file] 切换到分支 git merge [分支file] 将分支合并到master get rm [file] 删除文件 git pull 获取服务器更新的代码 本地代码上传 创建一个空项目 –&gt; 获取url git remote add orgin [url] 连接远端仓库 git push -u origin master 将本地仓库与远端仓库origin别名对应 第一次提交代码-u git pull 获取服务器更新的代码 本地建仓库 → 托管到远端 123456789101112mkdit [dir]cd [dir]git initgit add .get statusgit commit -m '说明'git loggit reset --hard idgit refloggit remote add origin &lt;url&gt;git push -u origin mastergit pull Git日常工作流程 — 远端服务器项目已存在 12345678910111213git clone [url]cd [dir]git branch [分支file] 创建分支名git branch 查看分支git checkout [分支file] 切换到分支git add .git commit -m '说明'git push origin [分支file]get checkout master 切回到mastergit merge [分支file] 将分支合并到mastergit push origin master","path":"2018/04/23/git版本控制软件的操作/"},{"title":"Pycharm的快捷键集合","text":"Windows下Python IDE PyCharm的基本快捷键和配置简介关于在windows下PyCharm的一些基本快捷键方式的整理集合 包括编辑、查找、运行、调试。。。 1、编辑（Editing) Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 Shift + F1 外部文档 Ctrl + 鼠标 简介 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + / 行注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 优化导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行 Ctrl + Y 删除选定的行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 另起一行 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Numpad+/- 展开折叠代码块 Ctrl + Numpad+ 全部展开 Ctrl + Numpad- 全部折叠 Ctrl + F4 关闭运行的选项卡 2、查找/替换(Search/Replace) F3 下一个 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + F 全局查找 Ctrl + Shift + R 全局替换 3、运行(Running) Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 4、调试(Debugging) F8 跳过 F7 进入 Shift + F8 退出 Alt + F9 运行游标 Alt + F8 验证表达式 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 5、导航(Navigation) Ctrl + N 跳转到类 Ctrl + Shift + N 跳转到符号 Alt + Right/Left 跳转到下一个、前一个编辑的选项卡 F12 回到先前的工具窗口 Esc 从工具窗口回到编辑窗口 Shift + Esc 隐藏运行的、最近运行的窗口 Ctrl + Shift + F4 关闭主动运行的选项卡 Ctrl + G 查看当前行号、字符号 Ctrl + E 当前文件弹出 Ctrl+Alt+Left/Right 后退、前进 Ctrl+Shift+Backspace 导航到最近编辑区域 Alt + F1 查找当前文件或标识 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到实现 Ctrl + Shift + I查看快速定义 Ctrl + Shift + B跳转到类型声明 Ctrl + U跳转到父方法、父类 Alt + Up/Down跳转到上一个、下一个方法 Ctrl + ]/[跳转到代码块结束、开始 Ctrl + F12弹出文件结构 Ctrl + H类型层次结构 Ctrl + Shift + H方法层次结构 Ctrl + Alt + H调用层次结构 F2 / Shift + F2下一条、前一条高亮的错误 F4 / Ctrl + Enter编辑资源、查看资源 Alt + Home显示导航条F11书签开关 Ctrl + Shift + F11书签助记开关 Ctrl + #[0-9]跳转到标识的书签 Shift + F11显示书签 6、搜索相关(Usage Search) Alt + F7/Ctrl + F7文件中查询用法 Ctrl + Shift + F7文件中用法高亮显示 Ctrl + Alt + F7显示用法 7、重构(Refactoring) F5复制F6剪切 Alt + Delete安全删除 Shift + F6重命名 Ctrl + F6更改签名 Ctrl + Alt + N内联 Ctrl + Alt + M提取方法 Ctrl + Alt + V提取属性 Ctrl + Alt + F提取字段 Ctrl + Alt + C提取常量 Ctrl + Alt + P提取参数 8、控制VCS/Local History Ctrl + K提交项目 Ctrl + T更新项目 Alt + Shift + C查看最近的变化 Alt + BackQuote(‘)VCS快速弹出 9、模版(Live Templates) Ctrl + Alt + J当前行使用模版 Ctrl +Ｊ插入模版 10、基本(General) Alt + #[0-9]打开相应的工具窗口 Ctrl + Alt + Y同步 Ctrl + Shift + F12最大化编辑开关 Alt + Shift + F添加到最喜欢 Alt + Shift + I根据配置检查当前文件 Ctrl + BackQuote(‘)快速切换当前计划 Ctrl + Alt + S 打开设置页 Ctrl + Shift + A查找编辑器里所有的动作 Ctrl + Tab在窗口间进行切换","path":"2018/04/23/pycharm的快捷键集合/"},{"title":"Linux系统的基础操作命令","text":"Linux系统历史Linux系统历史unix – minix – linux （linux是通用操作系统 ）第一台计算机 – 由Pascal 发明的第一台数字计算机 – 差分机 – 程序控制硬件工作 - Ada（女的）世界上第一个程序员第一台电子数字计算机 –ENIAC 冯诺依曼计算机 linux - 是系统内核发行版本：RedHat Linux、Ubuntu、CentOS","path":"2018/04/20/Linux系统的基础操作命令/"},{"title":"CSS层叠样式表知识汇总","text":"CSS什么是 CSS? CSS 指层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式通常存储在样式表中 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在 CSS 文件中 多个样式定义可层叠为一 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明，声明总是以分号(;)结束，声明组以大括号({})括起来 就近原则 具体性原则 id选择器&gt;类选择器&gt;标签选择器&gt;通配符选择器 重要性原则 ！important 盒子模型 1content（内容） - padding（内边距） - border（边框） - background-image（背景图片） - background-color（背景颜色） - margin（外边距） 边框和轮廓border 设置对象边框的特性 border-collapse : collapse 设置表格的边框合并为一个单一的边框 border-color 设置或检索对象的边框颜色 outline 设置或检索对象外的线条轮廓。 字体font-size 设置字体大小 font-family 规定文本的字体系列 font-style 规定文本的字体尺寸 font-weight 规定字体的粗细 文本color 指定文本的颜色 line-height 设置行高 text-align 规定文本的水平对齐方式 text-decoration 规定添加到文本的装饰效果，：none取消下划线 内边距padding 简写属性在一个声明中设置所有填充属性。该属性可以有1到4个值 padding-bottom 设置元素的底填充padding-left 设置元素的左填充padding-right 设置元素的右填充padding-top 设置元素的顶部填充 背景div是不支持background-color 的，background-color是table等的属性，你要用background：#（这里是颜色代码）；这样来写 background 复合属性，设置对象的背景特性 background-color 设置或检索对象的背景颜色background-image 设置或检索对象的背景图像 外边距margin 在一个声明中设置所有外边距属性，该属性可以有1到4个值 display属性display：none 此元素不会被显示。 display：block 此元素将显示为块级元素，此元素前后会带有换行符。 display：inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 hidden 元素是不可见的。 列表list-style 在一个声明中设置所有的列表属性list-style-position 设置列表项标记的放置位置 定位position:static; 正常文档流 position:relative; 相对定位 相对于元素原来的位置定位没有脱离文档流,对兄弟元素没有影响 position:absolute; 绝对定位(相对于父元素来设置位置 脱离了文档流 position:fixd； 固定定位（相对于浏览器窗口摆放） z-index 属性指定一个元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 float：left 元素向左浮动。 float：right 元素向右浮动。 黑科技 overflow: auto; 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 overflow: hidden 兄弟选择器 ~ 相邻兄弟选择器 + 12345安装字体@font-face &#123; font-family: '给字体起个名 '; src: url(路径);&#125;","path":"2018/04/14/CSS层叠样式表知识汇总/"},{"title":"JavaScript基础","text":"JavaScript​ ECMAScript - 语法规范 - ES5 (ECMA欧洲计算机制造商协会) ​ BOM - Browser Object Model - 浏览器对象模型 - window ​ DOM - Document Object Model - 文档对象模型 - document 编程范式(理念) 面向对象编程 函数式编程 层叠样式表前置, JS后置 123外部脚本不能包含 &lt;script&gt; 标签。 document.getElementById(\"some id\") 。这个方法是 HTML DOM 中定义的, 是用于访问 HTML 元素的正式 W3C 标准x.innerHTML=\"Hello JavaScript\"; //改变内容 输出JavaScript 显示数据 JavaScript 可以通过不同的方式来输出数据： 使用 window.alert() 弹出警告框。 alert() 方法用于显示带有一条指定消息和一个 确认 按钮的警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 操作 HTML 元素 如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。 请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容： 语法JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值 JavaScript 对大小写是敏感的 分号用于分隔 JavaScript 语句。通常我们在每条可执行的语句结尾添加分号。使用分号的另一用处是在一行中编写多条语句。 在文本字符串中使用反斜杠对代码行进行换行 注释单行注释以 // 开头 多行注释以 / 开始，以 / 结尾 数据类型和变量1234567891011121314151617181920212223简单数据类型:字符串（String） 、数字(Number) 、布尔(Boolean) 、数组(Array) 、空（Null） 、未定义（Undefined） 复杂数据类型: 对象(Object) 当声明新变量时，可以使用关键词 \"new\" 来声明其类型：JavaScript中有隐式的类型转换==比较，它会自动转换数据类型再比较===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 ===(全等于/严格等) !==(严格不等)逻辑运算符: &amp;&amp;(短路与) 只有所有都为true，&amp;&amp;运算结果才是true，第一个为false后面的不再判断||(短路或) 只要其中有一个为true，||运算结果就是true，第一个为true后面的不再判断! (非) 作用域局部作用域变量在函数内声明，变量为局部作用域。 局部变量：只能在函数内部访问。 全局作用域变量在函数外定义，即为全局变量。 全局变量有 全局作用域 : 网页中所有脚本和函数均可使用。 如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。 JavaScript 变量生命周期JavaScript 变量生命周期在它声明时初始化。 局部变量在函数执行完毕后销毁。 全局变量在页面关闭后销毁。 JavaScript全局函数isNaN() - 是不是不是一个数 parseInt() - 取整数如果取不出返回NaN parseFloat() - 取小数如果取不出返回NaN isFinite() - 是不是有限数值 eval() - 非常强大的函数 evaluate - XSS(跨站脚本攻击) encodeURIComponent() - 处理成百分号编码 decodeURIComponent() - 将百分号编码解码还原 Date 对象创建 Date 对象： new Date() 方法 描述 getFullYear() 从 Date 对象以四位数字返回年份 getMonth() 从 Date 对象返回月份 (0 ~ 11) getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31) getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6) getHours() 返回 Date 对象的小时 (0 ~ 23) getMinutes() 返回 Date 对象的分钟 (0 ~ 59) getSeconds() 返回 Date 对象的秒数 (0 ~ 59) trim() 函数用于去除字符串两端的空白字符 parseInt() 将字符串转换成整数,提取数字 disabled .onclick 绑定与反绑定 递归定义 - - 定义的左边和定义的右边出现了相同的概念 递归调用 - - 函数直接或间接的调用了自身 收敛条件 - 什么时候就不用递归了 递归公式 全排列 迷宫寻路 ==卡特兰数== window对象1234567891011121314151617181920212223alert() 浏览器弹出带有一段消息和一个确认按钮的警告框prompt() 显示可提示用户输入的对话框confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框open() 打开一个新的浏览器窗口或查找一个已命名的窗口close() 关闭浏览器窗口setTimeout() 在指定的毫秒数后调用函数或计算表达式setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式clearTimeout() 取消由 setTimeout() 方法设置的 timeout clearInterval() 取消由 setInterval() 设置的 timeoutmoveTo() 把窗口的左上角移动到一个指定的坐标moveBy() 可相对窗口的当前坐标把它移动指定的像素resizeBy() 按照指定的像素调整窗口的大小 window对象属性1234567891011location - 用于窗口或框架的 Location 对象属性:location.href 设置或返回当前显示的文档的完整 URLdocument.write(location.href);Location 对象方法:assign() 载入一个新的文档 // window.location.assign(URL)reload() 重新载入当前文档 // location.reload();replace() 用新的文档替换当前文档 // location.replace(newURL)history - go() / fofward / backscreen = avaiwidth / avaiHeight Document 对象查找元素的方法 getElementById() 返回对拥有指定 id 的第一个对象的引用 getElementsByTagName() 返回带有指定标签名的对象集合 getElementsByClassName() 返回文档中所有指定类名的元素集合 querySelector() 根据指定的选择器查找单个元素 querySelectorAll() 根据指定的选择器查找所有元素 绑定事件与取消绑定 document.addEventListener() 方法用于向文档添加事件句柄 document.removeEventListener() 方法来移除 addEventListener() 方法添加的事件句柄 element.addEventListener() 方法为指定元素添加事件句柄 1234document.addEventListener(event, function)- event 必需。描述事件名称的字符串。'click' - 当用户点击某个对象时调用的事件句柄 - function 必需。描述了事件触发后执行的函数 修改节点的内容和属性 textContent / innerHTML / nodeValue 访问成员运算符 setAttribute() / getAttribute() / removeAttribute() 创建新节点 - ()追加新的子节点 - appendChild() / insertBefore()删除子节点 - removeChild() 如果已经获得一个节点 如何访问它的父节点、子节点、兄弟节点parentNodechildren / firstChild / lastChildnextSibling / prevSibling DOM事件对象鼠标事件 onmousedown 鼠标按钮被按下 target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口 1event.target 事件捕获 - 从外向里传播事件 事件冒泡 - 从里向外传播事件 jQuery jQuery的$函数的作用: 1、 $(function() {}) - \\$函数中传入的参数是一个函数作用: 绑定页面加载完成之后要执行的回调函数 2、 $(selector) - \\$函数中传入的参数是一个选择器 ​ 作用: 通过选择器获得对应的元素并将其处理成jQuery对象jQuery对象本质是一个数组 ​ 如果需要将jQuery对象还原成原生的JS对象一[index]/get(index) 3、 $(elem) - \\$函数中传入的参数是原生JS对象 ​ 作用: 将原生JS对象转换成jQuery对象(更多的属性更多的方法) 4、 $(tag) - \\$函数中传入的参数是一个标签 ​ 作用: 和标签对应的元素(得到的是jQuery对身) 通过jQuery对象的方法可以用更少的代码做更多的事情 在写代码的时候不需要考虑浏览器兼容性问题(jQuery已经做了处理） 引入多个JS库出现冲突时可以通过下面的方式让出$函数 ​ jQuery.noConfict() ; 让出$函数以后原来用\\$函数的地方全部换成jQuery 查找元素: 选择器 12- * / element / #id / .class / selector1, selector2- ancestor descendant / parent&gt;child / previous+next / previous~siblings 筛选器 12345- 基本筛选器：:not(selector) / :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus- 内容筛选器：:contains('…') / :empty / :parent / :has(selector)- 可见性筛选器：:hidden / :visible- 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child- 属性筛选器：[attribute] / [attribute='value'] / [attribute!='value'] / [attribute^='value'] / [attribute$='value'] / [attribute|='value'] / [attribute~='value'] 表单： 1:input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked 执行操作 内容操作 1234- 获取/修改内容：html() / text() / replaceWith() / remove()- 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add()- 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css()- 获取/设置表单值：val() 查找操作 123- 查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll()- 筛选器：filter() / not() / has() / is() / contains()- 索引编号：eq() 尺寸和位置 12- 尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight()- 位置相关：offset() / position() / scrollLeft() / scrollTop() 特效和动画 1234- 基本动画：show() / hide() / toggle()- 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle()- 滑动效果：slideDown() / slideUp() / slideToggle()- 自定义：delay() / stop() / animate() 事件 12- 文档加载：ready() / load()- 用户交互：on() / off() 回调函数: evt参数代表的是事件对象 - 绑定了和事件相关的所有信息 如果事件回调函数中要用到和事件相关的属性和方法就最好指定evt参数 12- target / clientX / button / keyCode- preventDefault() / stopPropagation() 不管函数是否指定了evt参数当事件发生回调该函数时都会传入该参数 调构造函数 前面加new 数组里删元素要从后往前循环 Ajax原生Ajax - Asynchronous JavaScript and XML 让浏览器向服务器发出异步请求(非阻塞式请求)，等服务器返回了响应数据(JSON/XML)后就可以对页面进行局部刷 新，这样就可以在不中断用户体验的前提下刷新页面数据 JavaScript发送HTTP请求获取数据默认只支持同源数据(同源策略) http://www.abc.com/index.html -&gt; JavaScript 如果要跨域取数据是需要对方提供数据的服务器支持的 JSONP / 服务器端设置支持跨域取数据(RESTful)","path":"2018/04/12/JavaScript基础/"},{"title":"Html知识汇总","text":"什么是HTML?HTML 是用来描述网页的一种语言。 Tag: Content 装内容装数据 CSS: Display 渲染,显示 JavaScript: Behavior 交互,行为 HTML 指的是超文本标记语言: Hyper Text Markup Language HTML 不是一种编程语言，而是一种标记语言 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML 文档包含了HTML 标签及文本 内容 HTML文档也叫做web 页面 HTML格式1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;主题title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 解析12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt; 声明为 HTML5 文档&lt;html&gt; 元素是 HTML 页面的根元素&lt;head&gt; 元素包含了文档的元（meta）数据&lt;title&gt; 元素描述了文档的标题&lt;body&gt; 元素包含了可见的页面内容&lt;h1&gt; 元素定义一个大标题&lt;p&gt; 元素定义一个段落&lt;hr&gt; 水平分割线&lt;br&gt;折行符&lt;sub&gt;&lt;/sub&gt; 下标标签&lt;sup&gt;&lt;/sup&gt; 上标标签&lt;strong&gt;&lt;/strong&gt; 强调标签,变粗&lt;em&gt;&lt;/em&gt; 强调标签,斜体 列表无序列表12345&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;li&gt;芒果&lt;/li&gt;&lt;/ul&gt; 浏览器显示: 苹果 草莓 芒果 有序列表12345&lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;li&gt;芒果&lt;/li&gt;&lt;/ol&gt; 浏览器显示: 苹果 草莓 芒果 自定义列表123456789&lt;dl&gt; 标签定义一个描述列表。&lt;dl&gt; 标签与 &lt;dt&gt; （定义项目/名字）和 &lt;dd&gt; （描述每一个项目/名字）一起使用。&lt;dl&gt; &lt;dt&gt;星期&lt;/dt&gt; &lt;dd&gt;1 2 3 4 5 6 7&lt;/dd&gt; &lt;dt&gt;月份&lt;/dt&gt; &lt;dd&gt;1 2 3 4 5 6 7 8 9 10 11 12&lt;/dd&gt; &lt;/dl&gt; 浏览器显示: 星期​ 1 2 3 4 5 6 7月份​ 1 2 3 4 5 6 7 8 9 10 11 12 链接1&lt;a href=\"url\"&gt;链接文本&lt;/a&gt; href属性描述了链接的目标。 页面链接123456&lt;!-- 页面链接:可以链接到其他网站也可以链接到自己的页面 --&gt;当前页面跳转,target=\"_self\"可以不写&lt;a href=\"http://www.baidu.com\" target=\"_self\"&gt;百度&lt;/a&gt;&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;打开新页面跳转&lt;a href=\"http://www.qq.com\" target=\"_blank\"&gt;腾讯&lt;/a&gt; 锚点链接(id属性)12345678&lt;!-- 锚点链接:链接到指定位置 --&gt;id属性可用于创建在一个HTML文档书签标记。id=\"tips\" tips-提示部分,自己定义&lt;h1 id=\"top\"&gt;Hello,word!&lt;/h1&gt;&lt;a href=\"#top\"&gt;回顶部&lt;/a&gt; 功能性链接1234自动弹出发邮箱功能&lt;a href=\"mailto:fenghao1994@163.com\"&gt;联系站长&lt;/a&gt;发起消息会话,wp.qq.com网站自动生成&lt;a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=&amp;site=qq&amp;menu=yes\"&gt;&lt;img border=\"0\" src=\"http://wpa.qq.com/pa?p=2::52\" alt=\"联系客服\" title=\"联系客服\"/&gt;&lt;/a&gt; 图像定义图像的语法是: 1&lt;img src=\"url\" alt=\"som_text\" &gt; src 指 “source”。源属性的值是图像的 URL 地址,或图片的相对路径。 alt 为图像定义一串预备的可替换的文本。在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。 height（高度） 与 width（宽度）属性用于设置图像的高度与宽度，属性值默认单位为像素，也可以不设置。 1&lt;img src=\"./mm.jpg\" alt=\"这是一个女的\" width=\"300\" height=\"500\"&gt; 表格1234567891011121314151617181920212223&lt;table border=\"1\"&gt; &lt;caption&gt;个人信息统计&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;身高&lt;/th&gt; th&lt;th&gt;体重&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王大锤&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td colspan=\"2\" align=\"center\"&gt;170&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"..jpg\" width=\"60\" height=\"20\"&gt; &lt;div&gt;李小刀&lt;/div&gt; &lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;180&lt;/td&gt; &lt;td&gt;58&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;caption&gt; 定义表格标题 &lt;th&gt; 定义表格的表头 &lt;tr&gt; 定义表格的行 &lt;td&gt; 定义表格单元 align=&quot;center&quot; 居中 colspan=&quot;&quot; 合并 音频123456&lt;audio controls&gt; &lt;source src=\"horse.ogg\"&gt; &lt;source src=\"horse.mp3\"&gt;&lt;/audio&gt;controls 属性供添加播放、暂停和音量控件；可以换成autoplay 自动播放；autoplay loop自动循环播放。&lt;source&gt; 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件 视频1234&lt;video width=\"320\" height=\"240\" controls&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt;&lt;/video&gt; controls 元素提供了 播放、暂停和音量控件来控制视频。 width 和 height 属性控制视频的尺寸.尽量不要写 区块区块元素 12345大多数 HTML 元素被定义为块级元素或内联元素。块级元素在浏览器显示时，通常会以新行来开始（和结束）。实例: &lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;,&lt;div&gt; 内联元素 内联元素在显示时通常不会以新行开始。 123456789实例: &lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;&lt;div&gt; 元素&lt;div&gt; 元素是块级元素，它可用于组合其他 HTML 元素的容器。&lt;span&gt; 元素&lt;span&gt; 元素是内联元素，可用作文本的容器 表单1表单用于收集不同类型的用户输入。表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。表单使用表单标签 &lt;form&gt; 来设置 输入元素123多数情况下被用到的表单标签是输入标签（&lt;input&gt;）。输入类型是由类型属性（type）定义的。 文本域（Text Fields）12345678910111213141516171819文本域通过&lt;input type=\"text\"&gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。&lt;form action=\"\" method=\"post\" enctype=\"\"&gt; &lt;fieldset&gt; &lt;legend&gt;必填信息&lt;/legend&gt; &lt;p&gt; &lt;label&gt;用户名: &lt;/label&gt; &lt;input type=\"text\" name=\"uid\" placeholder=\"请输入用户名\" required&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;密码 &lt;/label&gt; &lt;input type=\"password\" name=\"pwd\"&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;性别: &lt;/label&gt; &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\" checked&gt;女 &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt; action “”里面是要提交的地址 method 规定如何发送表单数据（表单数据发送到 action属性所规定的页面）。共有两种方法：post 方法和 get 方法 – get get是从服务器上获取数据 get是把参数数据队列加到提交表单的action属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到 get传送的数据量较小。 get安全性非常低。 – post post是向服务器传送数据 post是通过HTTP post机制,将表单内各个字段与其内容放置在HTML HEADER内一起传送到action属性所指的URL地址。用户看不到这个过程。 post传送的数据量较大，一般被默认为不受限制。 post安全性较高。 enctype 属性规定在将表单数据发送到服务器之前如何对其进行编码。 注意：只有 method=”post” 时才使用 enctype 属性。 1234567891011121314151617&lt;fieldset&gt;&lt;/fieldset&gt; 定义了一组相关的表单元素，并使用外框包含起来&lt;legend&gt;&lt;/legend&gt; 定义了 &lt;fieldset&gt; 元素的标题&lt;label&gt; 定义了 &lt;input&gt; 元素的标签，一般为输入标题&lt;input&gt; 输入标签输入类型是由类型属性（type）定义的。name 属性规定表单的名称,用于在 JavaScript 中引用元素，或者在表单提交之后引用表单数据。placeholder 属性规定可描述输入字段预期值的简短的提示信息,该提示会在用户输入值之前显示在输入字段中。注意：placeholder 属性适用于下面的 input 类型：text、search、url、tel、email 和 password。required 属性是一个布尔属性,规定必需在提交表单之前填写输入字段。注意：required 属性适用于下面的 input 类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio 和 file。 密码字段1密码字段通过标签&lt;input type=\"password\"&gt; 来定义 单选按钮123&lt;input type=\"radio\"&gt; 标签定义了表单单选框选项checked选框默认选项 复选框1234567&lt;input type=\"checkbox\"&gt; 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项&lt;label&gt;爱好: &lt;/label&gt;&lt;input type=\"checkbox\" name=\"fav\"&gt;游戏&lt;input type=\"checkbox\" name=\"fav\" checked&gt;阅读&lt;input type=\"checkbox\" name=\"fav\" checked disabled&gt;旅游&lt;input type=\"checkbox\" name=\"fav\"&gt;运动&lt;input type=\"checkbox\" name=\"fav\"&gt;其他 checked disabled 默认必选项,不能取消. 文件上传1&lt;input type=\"file\" name=\"photo1\" multiple&gt; multiple 可接受多个值的文件上传字段 日期1&lt;input type=\"date\" name=\"b\"&gt; 下拉列表选项1234567891011&lt;select&gt;定义了下拉选项列表&lt;option&gt;定义下拉列表中的选项&lt;label&gt;籍贯: &lt;/label&gt;&lt;select&gt;name=\"prov\" &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option selected&gt;四川&lt;/option&gt; &lt;option&gt;云南&lt;/option&gt; &lt;option&gt;海南&lt;/option&gt;&lt;/select&gt; selected 默认选项 多行文本框1&lt;textarea&gt; 标签定义一个多行的文本输入控件。文本区域中可容纳无限数量的文本，其中的文本的默认字体是等宽字体（通常是 Courier）。可以通过 cols 和 rows 属性来规定 textarea 的尺寸大小 字符实体12345678910111213141516 空格 &amp;nbsp;&lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt;&amp; 和号 &amp;amp;\" 引号 &amp;quot;' 撇号 &amp;apos; (IE不支持)￠ 分 &amp;cent;£ 镑 &amp;pound; ¥ 人民币/日元 € 欧元 &amp;euro;§ 小节 &amp;sect;× 乘号 &amp;times; ÷ 除号 &amp;divide;© 版权 &amp;copy;® 注册商标 &amp;reg;™ 商标 &amp;trade;","path":"2018/04/02/Html知识汇总/"}]}